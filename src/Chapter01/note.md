# 第一章 简介

为什么要编写并发程序？

* 线程是Java语言中不可或缺的重要功能，他们能使复杂的异步代码变得简单，从而极大地简化了复杂系统的开发。
* 此外，要想发挥多处理器系统的强大计算能力，最简单的方式就是使用线程。

## 1.1并发简史

* 在早期的计算机中不包含操作系统，他们从头到尾只执行一个程序，并且这个程序能访问计算机中的所有资源。在这种裸机环境中，不仅很难编写和运行程序，而且每次只能运行一个程序，这对于昂贵并且稀有的计算机资源来说也是一种浪费。

* 操作系统的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行：**操作系统为各个独立执行的进程分配各种资源，包括内存、文件句柄以及安全证书等**。如果需要的话，在不同进程之间可以通过一些粗粒度的通信机制来交换数据，包括：**套接字、信号处理器、共享内存、信号量以及文件等**。

* 在计算机中加入操作系统来实现多个程序的同时执行，主要基于以下原因：

  1.  **资源利用率**

     在某些情况下，程序必须等待某个外部操作执行完成。如果在等待的同时可以运行另一个程序，那么无疑将提高资源的利用率。

  2.  **公平性**

     不同用户和程序对于计算机上的资源有着同等的使用权。一种高效的运行方式是通过粗粒度的**时间分片（Time Slicing）**使这些用户和程序能共享计算机资源，而不是由一个程序从头运行到尾，然后再启动下一个程序。

  3.  **便利性**

     通常来说，在计算多个任务时，应该编写多个程序，每个程序执行一个任务并在必要时相互通信，这比只编写一个程序来计算所有任务更容易实现。
  
* 在早期的分时系统中，每个进程相当于一台虚拟的冯诺依曼计算机，它拥有存储指令和数据的内存空间，根据机器语言的语义以串行方式执行指令，并通过一组I/O指令与外部设备通信。对每条被执行的指令，都有相应的“下一条指令”，**程序中的控制流是按照指令集的规则来确定的**。当前，几乎所有的主流编程语言都遵循这种串行编程的模型，并且在这些语言的规范中都清晰地定义了在某个动作完成之后需要执行的“下一个动作”。

* 线程允许在同一个进程中同时存在多个**程序控制流**。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程都具有各自的程序计数器（Program Counter）、栈以及局部变量等。线程还提供了一种直观的**分解模式**来充分利用多处理器系统中的硬件并行性，而在同一个程序中的多个线程也可以被同时调度到多个CPU上运行。

* 线程也被称为轻量级进程。在大多数现代操作系统中，都是以线程为基本的调度单位。

  * 由于同一个进程中的所有线程都将共享进程的内存地址空间，因此这些线程都能访问相同的变量并在一个堆上分配对象，这就需要实现一种比在进程间共享数据粒度更细的数据共享机制。如果没有明确的**同步机制**来协同对共享数据的访问，那么当一个线程正在使用某个变量时，另一个线程可能同时访问这个变量，这将造成不可预测的结果。

## 1.2线程的优势

### 1.2.1 发挥多处理器的强大能力

* 由于基本的调度单位是线程，因此如果在程序中只有一个线程，那么最多同时只能在一个处理器上运行。在双处理器系统上，单线程的程序只能使用一半的CPU资源，而在拥有100个处理器的系统上，将有99%的资源无法使用。
* 使用多个线程还有助于在单处理器系统上获得更高的吞吐率。如果程序是单线程的，那么当程序等待某个同步I/O操作完成时，处理器将处于空闲状态。而在多线程程序中，如果一个线程在等待I/O操作完成，另一个线程可以继续运行，使程序能够在I/O阻塞期间继续运行。

### 1.2.2 建模的简单性

* 当只有一种类型的任务需要完成时，只需埋头工作，直到完成所有的任务。如果需要完成多种类型的任务，那么需要管理不同任务之间的**优先级**和**执行时间**，并在任务之间进行切换，这将带来额外的开销。
* 编写包含多种任务的程序时，如果为模型中每种类型的任务都分配一个专门的线程，那么可以形成一种串行执行的假象，并将程序的**执行逻辑**与**调度机制**的细节，**交替执行**的操作，**异步I/O**以及**资源等待问题**分离开来。通过使用线程，可以将复杂并且异步的工作流一步分解为一组简单并且同步的工作流，每个工作流在一个单独的线程中运行，并在特定的同步位置进行交互。
* 我们可以通过现有的框架来实现上述目标,例如`Servlet`和`RMI(Remote Method Invocation)`。

### 1.2.3 异步事件的简化处理

* 先来看一下操作I/O时涉及的对象和步骤（这里我们以read为例）：

  这里涉及两个**系统对象**，一个是调用这个I/O的应用进程（或线程），另一个就是系统内核。

  当一个read操作发生时，它会经历两个**阶段**（这两个阶段很重要，因为**各种I/O模型的区别**就是在这两个阶段上各有不同的情况）：

  1. 等待数据就绪（可读）；2. 将数据从内核拷贝到应用进程中。

* **同步I/O操作**（synchronous I/O operation）导致请求进程阻塞，直到I/O操作完成。UNP第6章中提到的I/O模型——阻塞式I/O模型、非阻塞式I/O模型、I/O复用模型和信号驱动式I/O模型都是同步I/O模型，因为其中真正的I/O操作将阻塞进程。
* **异步I/O操作**（asynchronous I/O operation）不导致请求进程阻塞。
* 同步I/O需要进程真正地去操作I/O，而异步I/O则由内核在I/O操作完成后再通知应用进程结果。

* 5种I/O模型的比较表：

  ![Z23CRI.png](https://s2.ax1x.com/2019/07/11/Z23CRI.png)

  由上图，我们可以知道，除了异步I/O模型，其他模型都会实际阻塞于真正的I/O操作（不包括图中的’检查‘）。上图也说明了非阻塞式I/O虽然在检查阶段不会阻塞，但在文件描述符就绪（如可读）的时候是会阻塞的，这是它区别于异步I/O很重要的一点。

* **同步I/O操作**

  1. 阻塞式I/O模型

     * 在Linux中，默认情况下所有的套接字都是阻塞的。以数据报套接字为例，一个典型的读操作流程大概是这样：

       ![Z26XOU.png](https://s2.ax1x.com/2019/07/11/Z26XOU.png)

     * 进程调用`recvfrom`,其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。最常见的错误是系统调用被信号中断。我们说进程在从调用`recvfrom`开始到它返回的整段时间内是被阻塞的。`recvfrom`成功返回后，应用进程开始处理数据报。

  2. 非阻塞式I/O模型

     * 进程把一个套接字设置成非阻塞是在通知内核：当所请求的I/O操作非得把进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误。如下例：

       ![Z2oQaV.png](https://s2.ax1x.com/2019/07/11/Z2oQaV.png)

     * 前三次调用`recvfrom`时没有数据可返回，因此内核转而立即返回一个`EWOULDBLOCK`	错误。第四次调用`recvfrom`时已有一个数据报准备好，它被复制到应用进程缓冲区，	于是`recvfrom`成功返回。我们接着处理数据。

     * 当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，我们称之为轮询（polling）。**应用进程持续轮询内核，以查看某个操作是否就绪。这么做往往耗费大量CPU时间。**

  3. I/O复用模型

     * 关于I/O多路复用（又被称为“事件驱动”），首先要理解的是，操作系统为你提供了一个功能，当你的某个socket可读或者可写的时候，它可以给你一个通知。这样当配合非阻塞socket使用时，只有当系统通知我哪个描述符可读了，我才去执行read操作，可以保证每次read都能读到有效数据而不纯返回-1和EAGAIN的无用功。

     * 操作系统的这个功能通过select/poll/epoll/kqueue之类的系统调用函数来使用，这些函数都可以同时监视多个描述符的读写就绪状况。**这样，多个描述符的I/O操作都能在一个线程内并发交替地顺序完成，这就叫I/O多路复用。这里的“复用”指的是复用同一个线程。**

       [![ZRCYtg.png](https://s2.ax1x.com/2019/07/11/ZRCYtg.png)](https://imgchr.com/i/ZRCYtg)

     * I/O复用 劣势：select需要使用两个系统调用、优势：select可以等待多个描述符就绪。

  4. 信号驱动式I/O模型

     * 我们首先开启套接字的信号驱动式I/O功能，并通过`sigaction`系统调用安装一个信号处理函数。**该系统调用将立即返回，我们的进程继续工作， 也就是说它没有被阻塞。**当数据报准备好读写时，内核就为该进程产生一个`SIGIO`信号。我们随后既可以在信号处理函数中调用`recvfrom`读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。
     * ![ZRiGWQ.png](https://s2.ax1x.com/2019/07/11/ZRiGWQ.png)

* **异步I/O操作**

  * 一般来说，用于实现异步I/O的函数的工作机制是：**告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们**。

  * 这种模型与前面介绍的信号驱动模型的主要区别在于：信号驱动式I/O是由内核通知我们何时可以启动一个I/O操作，而异步I/O模型是内核通知我们I/O操作何时完成。

  * 如下例：

    ![ZRkK58.png](https://s2.ax1x.com/2019/07/11/ZRkK58.png)

    我们调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。该系统调用立即返回，而且在等待I/O完成期间，我们的进程不被阻塞。本例子中，我们假设要求内核在操作完成时产生某个信号，该信号直到数据已复制到应用进程缓冲区时才发生。

